
"use client";

import React from "react";
import { useState } from 'react';
import { useForm, useFieldArray } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Checkbox } from '@/components/ui/checkbox';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Wand2, Loader2, UploadCloud, Trash2, Sparkles, Info } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { generateBulkItems } from '@/ai/flows/generateBulkItems';
import { useAppContext } from '@/context/AppContext';
import { menuItemSchema } from '@/lib/schemas';
import Image from 'next/image';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { type MenuItem, type Category } from '@/lib/types';
import { Progress } from '@/components/ui/progress';

// We define the schema for the items generated by AI for the review table.
// This is now the source of truth for the shape of the data in the form.
export const GeneratedItemSchema = menuItemSchema.extend({
  id: z.string(), // The form array needs an ID
  imageHint: z.string().optional(),
});
export type GeneratedItem = z.infer<typeof GeneratedItemSchema>;


const bulkUploaderSchema = z.object({
  items: z.array(GeneratedItemSchema),
});

type BulkUploaderFormValues = z.infer<typeof bulkUploaderSchema>;

function BulkUploader() {
  const { toast } = useToast();
  const { categories, addMenuItem, addCategory } = useAppContext();
  const [rawInput, setRawInput] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [progress, setProgress] = useState(0);
  const [progressText, setProgressText] = useState('');


  const form = useForm<BulkUploaderFormValues>({
    resolver: zodResolver(bulkUploaderSchema),
    defaultValues: {
      items: [],
    },
  });

  const { fields, append, remove } = useFieldArray({
    control: form.control,
    name: 'items',
  });

  // Helper function to find or create a category ID
  const getCategoryId = async (name: string, localCategories: Category[]): Promise<string> => {
    const existingCategory = localCategories.find(c => c.name.toLowerCase() === name.toLowerCase());
    if (existingCategory) {
      return existingCategory.id;
    }
    
    // If not found, create it and return the new ID.
    console.log(`Category "${name}" not found. Creating it...`);
    try {
      const newCategory = await addCategory({ name });
      if (newCategory) {
        toast({ title: 'AI created a new category!', description: `Category "${name}" has been added.` });
        return newCategory.id;
      }
      throw new Error("Category creation returned undefined");
    } catch(e) {
      console.error(`Failed to create category "${name}":`, e);
      // Fallback to a default category if creation fails
      const defaultCategory = localCategories.find(c => c.name.toLowerCase() === 'uncategorized');
      return defaultCategory ? defaultCategory.id : '';
    }
  };
  
  const handleGenerate = async () => {
    // 1. Pre-processing Input
    const lines = rawInput.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    if (lines.length === 0) {
      toast({ title: 'Input required', description: 'Please enter at least one item name.', variant: 'destructive' });
      return;
    }

    setIsGenerating(true);
    setError(null);
    form.reset({ items: [] });
    setProgress(0);
    setProgressText('');

    let lastSeenCategory = '';
    let failedCount = 0;
    let successfulCount = 0;
    
    // Create a mutable copy of categories to update as we add new ones
    let localCategories = [...categories];

    const allVariants: { line: string, category: string }[] = [];
    let currentItemBaseName = '';

    for (const line of lines) {
        // This is a simple heuristic: if the line does NOT contain a price-like pattern, it's a category.
        const isHeading = !/[-–—:]\s*₹?\s*(\d|\()/.test(line);

        if (isHeading) {
            lastSeenCategory = line.replace(/[:(].*/, '').trim(); // Clean up the category name
            continue; 
        }

        // Handle lines with multiple prices (e.g., Single/Full)
        const priceVariants = line.split('|').map(v => v.trim());
        const itemNameMatch = priceVariants[0].match(/^([^:-–—]+)/);
        currentItemBaseName = itemNameMatch ? itemNameMatch[0].trim() : '';

        priceVariants.forEach(variantLine => {
            let fullLine = variantLine;
            // If a variant part doesn't contain the base name, prepend it. e.g. `(Full) 220` becomes `Veg Fried Rice (Full) 220`
            if (!variantLine.toLowerCase().includes(currentItemBaseName.toLowerCase())) {
                fullLine = `${currentItemBaseName} ${variantLine}`;
            }
            allVariants.push({ line: fullLine, category: lastSeenCategory });
        });
    }

    for (let i = 0; i < allVariants.length; i++) {
        const variant = allVariants[i];
        
        const currentProgress = Math.round(((i + 1) / allVariants.length) * 100);
        setProgress(currentProgress);
        setProgressText(`Processing item ${i + 1} of ${allVariants.length}...`);

        try {
            const result = await generateBulkItems({ 
                itemInput: variant.line,
                lastSeenCategory: variant.category
            });

            // The flow now returns undefined for skipped lines, so we check for a valid result.
            if (result && result.name) {
                const item = result;
                const categoryId = await getCategoryId(item.category, localCategories);
                
                if (!localCategories.some(c => c.id === categoryId)) {
                    localCategories.push({id: categoryId, name: item.category});
                }
                
                // Assign a temporary ID here in the UI layer.
                const itemWithId = {
                  ...item,
                  category: categoryId,
                  id: `temp-${Date.now()}-${Math.random()}`,
                };
                
                append(itemWithId);
                successfulCount++;
            } else {
                // This accounts for lines that were intentionally skipped (e.g., headings)
                // or failed to generate. No need to increment failedCount here as the flow handles logging.
            }
        } catch (e) {
            failedCount++;
            console.error(`Failed to process variant:`, variant.line, e);
        }
    }

    if (failedCount > 0) {
        setError(`${failedCount} item variants could not be processed. Please check the logs and your input format, then try again.`);
    }

    toast({ 
        title: 'Generation Complete!', 
        description: `Successfully processed ${successfulCount} items. Please review before uploading.` 
    });

    setIsGenerating(false);
    setProgress(0);
    setProgressText('');
  };

  const onSubmit = async (data: BulkUploaderFormValues) => {
    if(data.items.length === 0) {
        toast({ title: 'No items to upload', description: 'Please generate and review items first.', variant: 'destructive' });
        return;
    }
    setIsSubmitting(true);
    try {
        const creationPromises = data.items.map(item => {
            // Remove the temporary 'id' and 'imageHint' if it exists, as it's not part of the final MenuItem schema in the DB.
            const { id, imageHint, ...itemToCreate } = item;
            
            const payload: Omit<MenuItem, 'id'> = {
                ...itemToCreate,
                // Ensure imageHint is a simple string derived from the name
                imageHint: item.name.toLowerCase().split(' ').slice(0, 2).join(' '),
            };
            return addMenuItem(payload);
        });

        await Promise.all(creationPromises);

        toast({ title: 'Upload Successful!', description: `${data.items.length} items have been added to the menu.` });
        form.reset({ items: [] });
        setRawInput('');

    } catch (error) {
        console.error('Bulk upload failed:', error);
        toast({ title: 'Upload Failed', description: 'Could not add items to the menu. Please try again.', variant: 'destructive' });
    } finally {
        setIsSubmitting(false);
    }
  };

  return (
    <Card className="border-yellow-500/50 border-2 shadow-lg">
      <CardHeader>
        <CardTitle className="font-headline text-2xl bg-gradient-to-r from-yellow-400 to-amber-600 text-transparent bg-clip-text flex items-center gap-2">
            <Sparkles className="text-yellow-500"/>
            AI Genesis Uploader
        </CardTitle>
        <CardDescription>
          Paste your menu, and our advanced AI will intelligently parse, enrich, and prepare each item for your restaurant.
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <Alert>
          <Info className="h-4 w-4" />
          <AlertTitle>How to Format Your Menu</AlertTitle>
          <AlertDescription>
            For best results, use clear patterns. Put each category on its own line (e.g., `Soups`). Put each item on a new line with its price (e.g., `Tomato Soup - 150`). For items with multiple prices, use a pipe `|` (e.g., `Fried Rice: (Single) 130 | (Full) 180`).
          </AlertDescription>
        </Alert>
        <div className="grid w-full gap-2">
          <Textarea
            placeholder="Soups
Tomato Soup – 150
...
Veg Fried Rice: (Single) 130 | (Full) 180
...
"
            value={rawInput}
            onChange={(e) => setRawInput(e.target.value)}
            rows={10}
            disabled={isGenerating || isSubmitting}
            className="focus-visible:ring-yellow-500"
          />
          <Button onClick={handleGenerate} disabled={isGenerating || isSubmitting || !rawInput.trim()} className="bg-gradient-to-r from-yellow-400 to-amber-600 text-white hover:opacity-90">
            {isGenerating ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Wand2 className="mr-2 h-4 w-4" />}
            {isGenerating ? 'Generating...' : 'Generate & Review'}
          </Button>
        </div>
        {isGenerating && (
            <div className="space-y-2">
                <Progress value={progress} className="w-full [&>div]:bg-yellow-500" />
                <p className="text-sm text-muted-foreground text-center">{progressText}</p>
            </div>
        )}
        {error && (
            <Alert variant="destructive">
                <AlertTitle>Generation Issue</AlertTitle>
                <AlertDescription>{error}</AlertDescription>
            </Alert>
        )}
      </CardContent>

      {fields.length > 0 && (
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)}>
            <CardContent>
                <h3 className="text-lg font-medium mb-4">Review Generated Items</h3>
                <div className="border rounded-lg overflow-x-auto">
                    <Table>
                        <TableHeader>
                            <TableRow>
                                <TableHead className="w-[200px]">Name</TableHead>
                                <TableHead className="w-[300px]">Description</TableHead>
                                <TableHead className="w-[120px]">Price</TableHead>
                                <TableHead className="w-[180px]">Category</TableHead>
                                <TableHead className="w-[300px]">Image URL</TableHead>
                                <TableHead className="w-[250px]">Flags</TableHead>
                                <TableHead className="w-[50px]">Action</TableHead>
                            </TableRow>
                        </TableHeader>
                        <TableBody>
                            {fields.map((field, index) => (
                                <TableRow key={field.id}>
                                    <TableCell><Input {...form.register(`items.${index}.name`)} /></TableCell>
                                    <TableCell><Textarea {...form.register(`items.${index}.description`)} /></TableCell>
                                    <TableCell><Input type="number" {...form.register(`items.${index}.price`, { valueAsNumber: true })} /></TableCell>
                                    <TableCell>
                                        <FormField
                                            control={form.control}
                                            name={`items.${index}.category`}
                                            render={({ field }) => (
                                                <Select onValueChange={field.onChange} value={field.value}>
                                                    <FormControl><SelectTrigger><SelectValue /></SelectValue></FormControl>
                                                    <SelectContent>
                                                        {categories.map(cat => <SelectItem key={cat.id} value={cat.id}>{cat.name}</SelectItem>)}
                                                    </SelectContent>
                                                </Select>
                                            )}
                                        />
                                    </TableCell>
                                    <TableCell>
                                        <div className="flex flex-col gap-2">
                                            <Input {...form.register(`items.${index}.imageUrl`)} />
                                            <div className="relative aspect-video w-full rounded-md overflow-hidden border bg-muted">
                                                <Image src={form.watch(`items.${index}.imageUrl`) || '/placeholder.png'} alt="Preview" fill className="object-cover" />
                                            </div>
                                        </div>
                                    </TableCell>
                                    <TableCell className="space-y-3">
                                       <FormField control={form.control} name={`items.${index}.isAvailable`} render={({ field }) => (
                                            <FormItem className="flex items-center gap-2 space-y-0"><FormControl><Checkbox checked={field.value} onCheckedChange={field.onChange}/></FormControl><FormLabel className="font-normal">Available</FormLabel></FormItem>
                                        )} />
                                       <FormField control={form.control} name={`items.${index}.isVeg`} render={({ field }) => (
                                            <FormItem className="flex items-center gap-2 space-y-0"><FormControl><Checkbox checked={field.value} onCheckedChange={field.onChange}/></FormControl><FormLabel className="font-normal">Veg</FormLabel></FormItem>
                                        )} />
                                       <FormField control={form.control} name={`items.${index}.isSpicy`} render={({ field }) => (
                                            <FormItem className="flex items-center gap-2 space-y-0"><FormControl><Checkbox checked={field.value} onCheckedChange={field.onChange}/></FormControl><FormLabel className="font-normal">Spicy</FormLabel></FormItem>
                                        )} />
                                       <FormField control={form.control} name={`items.${index}.isChefsSpecial`} render={({ field }) => (
                                            <FormItem className="flex items-center gap-2 space-y-0"><FormControl><Checkbox checked={field.value} onCheckedChange={field.onChange}/></FormControl><FormLabel className="font-normal">Chef's Special</FormLabel></FormItem>
                                        )} />
                                    </TableCell>
                                    <TableCell>
                                        <Button variant="ghost" size="icon" onClick={() => remove(index)}>
                                            <Trash2 className="h-4 w-4 text-destructive" />
                                        </Button>
                                    </TableCell>
                                </TableRow>
                            ))}
                        </TableBody>
                    </Table>
                </div>
            </CardContent>
            <CardFooter>
                <Button type="submit" disabled={isSubmitting || isGenerating} className="bg-slate-700 text-white hover:bg-slate-800">
                    {isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <UploadCloud className="mr-2 h-4 w-4" />}
                    {isSubmitting ? 'Uploading...' : 'Upload All to Menu'}
                </Button>
            </CardFooter>
          </form>
        </Form>
      )}
    </Card>
  );
}

export default BulkUploader;

    