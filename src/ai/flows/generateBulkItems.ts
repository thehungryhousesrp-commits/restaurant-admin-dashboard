\'use server\';\n/**\n * @fileOverview An AI flow for generating full menu item details from a list of names.\n * This flow acts as the orchestrator, parsing core data and calling helper flows for enrichment.\n */\n\nimport { ai } from \'@/ai/genkit\';\nimport { z } from \'zod\';\nimport { findImageUrl } from \'./findImageUrl\';\nimport { generateDescription } from \'./generateDescription\';\n\n// --- 1. SCHEMAS ---\n\nconst VariantSchema = z.object({\n    label: z.string().describe(\'The label for the variant, e.g., "Single", "Full", or "Regular".\'),\n    price: z.number().describe(\'The price for this specific variant.\'),\n});\n\nconst CoreMetadataSchema = z.object({\n    name: z.string().describe(\'The clean name of the menu item.\'),\n    variants: z.array(VariantSchema).min(1).describe(\'An array of pricing variants for the item.\'),\n    category: z.string().describe(\'The primary category based on context or item name.\'),\n    isVeg: z.boolean().describe(\'True if the item is vegetarian.\'),\n    isSpicy: z.boolean().describe(\'True if the item is spicy.\'),\n    isChefsSpecial: z.boolean().describe(\'True if the item sounds like a chef special.\'),\n    isAvailable: z.boolean().default(true),\n});\n\nconst GeneratedItemSchema = CoreMetadataSchema.extend({\n    id: z.string(),\n    description: z.string(),\n    imageUrl: z.string().url().optional(),\n    imageHint: z.string().optional(),\n});\nexport type GeneratedItem = z.infer<typeof GeneratedItemSchema>;\n\nconst FailedItemSchema = z.object({\n    error: z.literal(true),\n    line: z.string(),\n    reason: z.string(),\n});\nexport type FailedItem = z.infer<typeof FailedItemSchema>;\n\nconst ReviewItemSchema = z.union([GeneratedItemSchema, FailedItemSchema]);\n\nconst BulkGenerateInputSchema = z.object({\n    itemInputs: z.array(z.object({\n        line: z.string(),\n        category: z.string(),\n    })).describe(\'An array of menu item lines and their contextual categories.\'),\n});\n\n\n// --- 2. AI PROMPTS ---\n\nconst parseCoreMetadataPrompt = ai.definePrompt({\n    name: \'parseCoreMetadataPrompt\',\n    input: { schema: z.object({ itemInput: z.string(), lastSeenCategory: z.string().optional() }) },\n    output: { schema: CoreMetadataSchema },\n    prompt: `\n        You are an expert data parser. Your task is to extract details from a single line of a restaurant menu. Be precise.\n        \n        **RULES:**\n        1.  **Variants:** The item may have multiple prices (e.g., "Single", "Full"). Extract these into a \`variants\` array. If there is only one price, use "Regular" as the label.\n        2.  **No Name/Price:** If a name or at least one price is not perfectly clear, you MUST return an empty array for \`variants\`.\n        3.  **Context:** Use the \`lastSeenCategory\` to inform the item\\\'s category.\n        \n        **EXAMPLES:**\n        *   Input Line: "Veg Fried Rice: (Single) 130 | (Full) 180", Category: "Rice"\n        *   Output:\n        \`\`\`json\n        {\n          "name": "Veg Fried Rice",\n          "variants": [\n            { "label": "Single", "price": 130 },\n            { "label": "Full", "price": 180 }\n          ],\n          "category": "Rice",\n          "isVeg": true,\n          "isSpicy": false,\n          "isChefsSpecial": false\n        }\n        \`\`\`\n        *   Input Line: "Margarita Pizza: 220", Category: "Pizza"\n        *   Output:\n        \`\`\`json\n        {\n          "name": "Margarita Pizza",\n          "variants": [\n            { "label": "Regular", "price": 220 }\n          ],\n          "category": "Pizza",\n          "isVeg": true,\n          "isSpicy": false,\n          "isChefsSpecial": false\n        }\n        \`\`\`\n        \n        **YOUR TASK:**\n        Input Line: {{{itemInput}}}\n        Contextual Category: {{{lastSeenCategory}}}\n        \n        Return a JSON object matching the schema.\n`,\n});\n\n// --- 3. SINGLE ITEM PROCESSING FLOW (Internal Helper) ---\nconst processSingleItemFlow = ai.defineFlow(\n    { name: \'processSingleItemFlow\' },\n    async (input: { line: string; category: string }): Promise<GeneratedItem | FailedItem> => {\n        const cleanInput = input.line.trim();\n        if (!cleanInput) return { error: true, line: "(Empty Line)", reason: "Line was empty or only whitespace." };\n\n        // Step 1: Parse Core Metadata\n        let coreMetadata;\n        try {\n            const { output } = await parseCoreMetadataPrompt({ itemInput: cleanInput, lastSeenCategory: input.category });\n            if (!output || output.name === \'N/A\' || output.variants.length === 0) {\n                return { error: true, line: cleanInput, reason: "Could not determine a clear name and at least one price." };\n            }\n            coreMetadata = output;\n        } catch (err: any) {\n            console.error(`Core parsing failed for "${cleanInput}":`, err);\n            return { error: true, line: cleanInput, reason: `AI parsing failed: ${err.message}` };\n        }\n\n        // Step 2: Enrich with Description and Image (sequentially to be safe)\n        let description = "A delicious menu item. Description will be added soon.";\n        let imageUrl: string | undefined = undefined;\n        let imageHint: string | undefined = undefined;\n\n        try {\n             const descResult = await generateDescription({ itemName: coreMetadata.name });\n             description = descResult.description;\n             const imageResult = await findImageUrl({ itemName: coreMetadata.name });\n             imageUrl = imageResult.imageUrl;\n             imageHint = imageResult.imageHint;\n        } catch (err: any) {\n            console.error(`Enrichment failed for ${coreMetadata.name}:`, err);\n            // Non-fatal: We can proceed without enrichment.\n        }\n\n        // Step 3: Assemble and Validate Final Object\n        try {\n            const finalItemData = {\n                ...coreMetadata,\n                description,\n                imageUrl,\n                imageHint,\n                id: \'\', // The frontend will assign a temporary ID\n            };\n\n            return GeneratedItemSchema.parse(finalItemData);\n\n        } catch (validationError: any) {\n            console.error(`Final validation failed for "${coreMetadata.name}":`, validationError);\n            return { error: true, line: cleanInput, reason: `Internal validation failed: ${validationError.message}` };\n        }\n    }\n);\n\n\n// --- 4. MAIN BULK GENERATION FLOW (Exported) ---\nexport const generateBulkItems = ai.defineFlow(\n  {\n    name: \'generateBulkItems\',\n    inputSchema: BulkGenerateInputSchema,\n    outputSchema: ReviewItemSchema, // Output is a single item for streaming\n  },\n  async (input, streamer) => {\n    console.log(`Starting stream generation for ${input.itemInputs.length} items.`);\n    \n    for (const item of input.itemInputs) {\n        const result = await processSingleItemFlow(item);\n        streamer.stream(result);\n    }\n\n    console.log(`Finished stream generation.`);\n  }\n).dotStream(); // Enable streaming\n